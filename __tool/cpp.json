{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }    
    "coutendl": {
        "prefix": "coutendl",
        "body": [
            "cout << $1 <<endl;"
        ]
    },
    "fortemp": {
        "prefix": "forobj",
        "body": [
            "for (int $1 = 0; $1 < $2.size(); $1++) {",
            "\tauto& $3 = $2[$1];",
            "}"
        ]
    },
    "forN": {
        "prefix": "forn",
        "body": [
            "for (int $1 = 0; $1 < $2; $1++) {",
            "\t",
            "}"
        ]
    },
    "forRev": {
        "prefix": "forrev",
        "body": [
            "for (int $1 = $2; $1 >= 0; $1--) {",
            "\t",
            "}"
        ]
    },
    "sortall": {
        "prefix": "sortobj",
        "body": [
            "sort($1.begin(), $1.end());"
        ]
    },
    "sortrev": {
        "prefix": "sortrev",
        "body": [
            "sort($1.begin(), $1.end());",
            "reverse($1.begin(), $1.end());"
        ]
    },
    "forall": {
        "prefix": "all",
        "body": [
            "$1.begin(), $1.end()"
        ]
    },
    "gcdlambda": {
        "prefix": "gcdlambda",
        "body": [
            "function<LL(LL, LL)> gcdlambda = [](LL n, LL m) { return __gcd(n, m);};"
        ]
    },
    "count": {
        "prefix": "count_",
        "body": [
            "int $1 = count($2.begin(), $2.end(), $3);",
        ]
    },
    "count_if": {
        "prefix": "countif_",
        "body": [
            "int $1 = count_if($2.begin(), $2.end(), [](auto x) {",
            "\tif ($3) return true;",
            "\treturn false;",
            "});"
        ]
    },
    "predicate": {
        "prefix": "predicate",
        "body": [
            "[&](int x) {",
            "  if($1) return true;",
            "  return false;",
            "}"
        ]
    },
    "partial_sum": {
        "prefix": [
            "partialsum",
            "ruiseki"
        ],
        "body": [
            "vector<$1> $2;",
            "partial_sum($3.begin(), $3.end(), back_inserter($2));$4"
        ]
    },
    "accumulate": {
        "prefix": "accumulate",
        "body": [
            "accumulate($1.begin(), $1.end(), 0LL);"
        ]
    },
    "simple_lambda": {
        "prefix": "lambda",
        "body": [
            "[$1]($2){",
            "\t$3",
            "}"
        ]
    },
    "squash": {
        "prefix": "squash",
        "body": [
            "vector<pair<$1, int> > $2;",
            "for(auto elem: $3 ){",
            "\tif($2.empty()||$2.back().first!=elem) $2.emplace_back(make_pair(elem, 0));",
            "\t$2.back().second++;",
            "}"
        ]
    },
    "DFSclass": {
        "prefix": "dfsclass",
        "body": [
            "class DFSClass {",
            " public:",
            "\t$1 input;",
            "\t$2 result;",
            "\tDFSClass(){result=$3;}",
            "\tvoid dfs(int level, int state) {",
            "\t\tif (hoge) {",
            "\t\t\tresult=update;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tdfs(level + 1, newState);",
            "\t}",
            "};"
        ]
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "queue<PII> qu;",
            "qu.push(PII(0, 0));",
            "auto dists = exvector(-1, H, W);",
            "dists[0][0] = 0;",
            "while (!qu.empty()) {",
            "\tauto cur = qu.front();",
            "\tqu.pop();",
            "\tint x = cur.first;",
            "\tint y = cur.second;",
            "\tif (field[x][y] == '#') continue;",
            "\tfor (int i = 0; i < 4; i++) {",
            "\t\tvector<int> dx = {-1, 0, 1, 0};",
            "\t\tvector<int> dy = {0, 1, 0, -1};",
            "\t\tint nx = x + dx[i];",
            "\t\tint ny = y + dy[i];",
            "\t\tif (!(nx >= 0 && nx < H && ny >= 0 && ny < W)) continue;",
            "\t\tif (dists[nx][ny] == -1) {",
            "\t\t\tdists[nx][ny] = dists[x][y] + 1;",
            "\t\t\tqu.push(PII(nx, ny));",
            "\t\t}",
            "\t}",
            "}",
        ]
    },
}