{
    "coutendl": {
		"prefix": "output",
		"body": [
			"cout << $1 <<endl;"
		]
	},
	"fortemp": {
		"prefix": "forvobj",
		"body": [
			"for (int $1 = 0; $1 < $2.size(); $1++) {",
			"\tauto& $3 = $2[$1];",
			"}"
		]
	},
	"forN": {
		"prefix": "forvn",
		"body": [
			"for (int $1 = 0; $1 < $2; $1++) {",
			"\t",
			"}"
		]
	},
	"forRev": {
		"prefix": "forvrev",
		"body": [
			"for (int $1 = $2; $1 >= 0; $1--) {",
			"\t",
			"}"
		]
	},
	"sortall": {
		"prefix": "sortvecobj",
		"body": [
			"sort($1.begin(), $1.end());"
		]
	},
	"sortrev": {
		"prefix": "sortvecrev",
		"body": [
			"sort($1.begin(), $1.end());",
			"reverse($1.begin(), $1.end());"
		]
	},
	"forall": {
		"prefix": "all",
		"body": [
			"$1.begin(), $1.end()"
		]
	},
	"gcdlambda": {
		"prefix": "gcdlambda",
		"body": [
			"function<LL(LL, LL)> gcdlambda = [](LL n, LL m) { return __gcd(n, m);};"
		]
	},
	"count": {
		"prefix": "count_",
		"body": [
			"int $1 = count($2.begin(), $2.end(), $3);",
		]
	},
	"count_if": {
		"prefix": "countif_",
		"body": [
			"int $1 = count_if($2.begin(), $2.end(), [](auto x) {",
			"\tif ($3) return true;",
			"\treturn false;",
			"});"
		]
	},
	"binary": {
		"prefix": "binary",
		"body": [
			"decision = function<(LL),bool>[&](LL) {};",
			"LL left = 0, right = 0;",
			"while(right - left > 1) {",
			"LL mid = (left + right) / 2;",
			"if(decision(mid)) right = mid;",
			"else left = mid;",
			"}",
			"LL ans = right;"
		]
	},
	"predicate": {
		"prefix": "decision",
		"body": [
			"[&](int x) {",
			"  if($1) return true;",
			"  return false;",
			"}"
		]
	},
	"partial_sum": {
		"prefix": [
			"partialsum",
			"ruiseki"
		],
		"body": [
			"vector<$1> $2;",
			"partial_sum($3.begin(), $3.end(), back_inserter($2));$4"
		]
	},
	"accumulate": {
		"prefix": "accumulate",
		"body": [
			"accumulate($1.begin(), $1.end(), 0LL);"
		]
	},
	"simple_lambda": {
		"prefix": "lambda",
		"body": [
			"[$1]($2){",
			"\t$3",
			"}"
		]
	},
	"squash": {
		"prefix": "squash",
		"body": [
			"vector<pair<$1, int> > $2;",
			"for(auto elem: $3 ){",
			"\tif($2.empty()||$2.back().first!=elem) $2.emplace_back(make_pair(elem, 0));",
			"\t$2.back().second++;",
			"}"
		]
	},
    "bfs" :{
        "prefix": "vvbfs",
        "body":[ 
			"auto bfs_func = [&](int root) {",
			"  // graph : g",
			"",
			"  vector<int> used(g.N, 0);",
			"  queue<int> qu;",
			"  qu.push(root);",
			"  while (!qu.empty()) {",
			"    int v = qu.front();",
			"    qu.pop();",
			"    used[v] = true;",
			"    for (auto edge : g.vs[v].es) {",
			"      int u = edge.to;",
			"      // int w = edge.field; // OPTION",
			"      if (used[u]) continue;",
			"      // FROM",
			"",
			"      // TO",
			"      qu.push(u);",
			"    }",
			"  }",
			"};",
			"bfs_func(0)",

        ]

    },
}